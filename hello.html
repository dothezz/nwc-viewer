<html>
<body>
	<h3>Hello Test</h3>

	<canvas id="canvas" width="900" height="400"></canvas>

	<!-- dependencies -->
	<script src="vendor/inflate.min.js"></script>
	<script src="node_modules/vexflow/releases/vexflow-min.js"></script>

	<script src="main.js"></script>

	<script>
	function vex() {
		// http://www.vexflow.com/docs/tutorial.html
		var canvas = document.getElementById('canvas');
		var renderer = new Vex.Flow.Renderer(canvas,
			Vex.Flow.Renderer.Backends.CANVAS);

		var LEFT_PADDING = 50;
		var WIDTH = canvas.width;
		var STAFF_HEIGHT = 100;

		var ctx = renderer.getContext();

		var staves = data.score.staves;


		canvas.height = staves.length * STAFF_HEIGHT;
		for (var s = 0; s < staves.length; s++) {
			//
			var tokens = staves[s].tokens;
			// console.log(tokens);

			var stave = new Vex.Flow.Stave(LEFT_PADDING, STAFF_HEIGHT * s, WIDTH);
			stave.setContext(ctx);

			// TODO delimit sections via clefs?
			tokens.some(function(token) {
				if (token.type == 'Clef') {
					console.log(token);
					stave.addClef(token.clef);
					return true;
				}
			});



			// Create the notes
			var notes = [
				// // A quarter-note C.
				// new Vex.Flow.StaveNote({ keys: ["c/4"], duration: "q" }),

				// // A quarter-note D.
				// new Vex.Flow.StaveNote({ keys: ["d/4"], duration: "q" }),

				// // A quarter-note rest. Note that the key (b/4) specifies the vertical
				// // position of the rest.
				// new Vex.Flow.StaveNote({ keys: ["b/4"], duration: "qr" }),

				// // A C-Major chord.
				// new Vex.Flow.StaveNote({ keys: ["c/4", "e/4", "g/4"], duration: "q" })
			];

			var voice;
			var limit = 0;
			tokens.forEach(function(token) {
				if (token.type == 'Note'
					// || token.type == 'Rest'
					) {
					limit++;
					// if (limit > 10) return;
					// console.log(token);;
					notes.push(new Vex.Flow.StaveNote({
						keys: [
							// "C" + token.accidental + "/4"
							token.name + token.accidental + '/' + token.octave
						],
						duration: token.duration + '' +
						(token.dots ? 'ddd'.slice(-token.dots) : ''),
						// dots: token.dots,
						// clef: "bass"
					}));
				}

				if (token.type == 'Barline') {
					notes.push(
						new Vex.Flow.BarNote()
					);
				}
				if (token.type == 'TimeSignature') {
					console.log(token);
					stave.addTimeSignature(token.signature);

					voice = new Vex.Flow.Voice({
						num_beats: token.group,
						beat_value: token.beat,
						resolution: Vex.Flow.RESOLUTION,
					});
				}
			});

			stave.draw();
			voice.setStrict(false);
			// voice.mode = Vex.Flow.Voice.Mode.SOFT;

			// Add notes to voice
			voice.addTickables(notes);

			// Format and justify the notes to 500 pixels
			var formatter = new Vex.Flow.Formatter().
				joinVoices([voice]).format([voice], WIDTH * 10);

			// Render voice
			voice.draw(ctx, stave);

		}
	}
	</script>
</body>